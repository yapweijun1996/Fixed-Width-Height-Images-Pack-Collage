<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Collage - No-Crop Column Flow + Balanced Row</title>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>

<h3>Image Collage - Fixed 640x500 (No Crop) — Column-first flow enabled</h3>

<!-- 說明：
  - data-flow="col" → 以「高度優先、由上到下，再由左到右」的欄式排法（滿高），適合 19/20 張等不等量
  - data-flow 可切換為 "row" → 使用 BalancedNoCrop 的等高列式排法（滿寬）
  - data-mincols / data-maxcols → 欄數搜尋範圍（欄式）
  - data-hgap / data-vgap → 欄間與圖間間距
-->
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
  data-flow="col"
  data-mincols="3"
  data-maxcols="6"
  data-hgap="4"
  data-vgap="4"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1025/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1003/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1024/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1027/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1028/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1029/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1031/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1032/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1033/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1043/1200/800.jpg"  alt="">
</div>

<div class="debug-info" id="debugInfo">Debug info will appear here...</div>

<script>
/*!
 * ColumnNoCrop v1.0 + BalancedNoCrop v4.0
 * - ColumnNoCrop（高度優先、欄式）：由上到下，再由左到右；每欄恰好填滿 H，不裁剪，不變形
 *   對 N=19/20 等不等量都穩定；自動搜索欄數與每欄張數分配，將橫向剩餘寬度分配到欄間距，避免水平留白帶來縫隙不齊
 * - BalancedNoCrop（寬度優先、列式）：滿寬、列高一致，已在前版驗證 >95% 利用率
 */
(function(){
  "use strict";
  const CLASS = "img_collage";

  // ---------- Debug Logger ----------
  function log(message, data) {
    const prefix = "";
    console.log(prefix + message, data ?? '');
    const debugDiv = document.getElementById('debugInfo');
    if (debugDiv) {
      const line = document.createElement('div');
      line.textContent = `${message} ${data !== undefined ? JSON.stringify(data) : ''}`;
      debugDiv.appendChild(line);
    }
  }

  // ---------- Helpers ----------
  const raf2 = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
  function preload(img){
    return new Promise(res=>{
      if (img.complete && img.naturalWidth>0) { res(); return; }
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    });
  }

  // ---------- ColumnNoCrop: compositions generator ----------
  function generateCompositions(n, k, cb) {
    // 產生 k 個正整數之組合，其和 = n；串流回呼避免大量內存
    function rec(parts, left, slots) {
      if (slots === 1) {
        cb([...parts, left]);
        return;
      }
      for (let t = 1; t <= left - (slots - 1); t++) {
        parts.push(t);
        rec(parts, left - t, slots - 1);
        parts.pop();
      }
    }
    rec([], n, k);
  }

  // ---------- ColumnNoCrop: solver ----------
  function solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols) {
    log('[ColumnNoCrop] Start', {W,H,N:aspects.length, minCols, maxCols});
    let best = null;

    for (let C = Math.max(1, minCols); C <= Math.max(minCols, maxCols); C++) {
      const gapSlots = Math.max(0, C - 1);

      generateCompositions(aspects.length, C, (counts) => {
        // 按順序切分到各欄（保留原有輸入順序）：上到下，再到下一欄
        let idx = 0;
        const cols = [];
        const widths = [];

        for (let j = 0; j < C; j++) {
          const cnt = counts[j];
          const list = aspects.slice(idx, idx + cnt);
          idx += cnt;

          const H_eff = H - vgap * Math.max(0, cnt - 1);
          const Sj = list.reduce((s, a) => s + 1 / Math.max(1e-9, a), 0); // Σ(1/a)
          const wj = H_eff / Math.max(1e-9, Sj); // 令欄寬 wj，使 Σ(wj/a) + gaps = H → 滿高

          cols.push({count: cnt, aspects: list});
          widths.push(wj);
        }

        const sumW = widths.reduce((s, v) => s + v, 0);
        const neededGap = (C > 1) ? (W - sumW) / (C - 1) : 0; // 讓總寬 + gap*(C-1) 精確 = W

        // 打分：禁止 neededGap 過小為負且過大；還要寬度分布均勻
        const meanW = sumW / C;
        const varW = widths.reduce((s, v) => s + (v - meanW) * (v - meanW), 0) / C;

        const overPenalty = neededGap < 0 ? Math.abs(neededGap) * 1000 : 0;
        const score = overPenalty + Math.abs(neededGap - hgap) * 3 + Math.sqrt(varW);

        if (!best || score < best.score) {
          best = {C, counts, cols, widths, neededGap, sumW, score};
        }
      });
    }

    if (best) {
      log('[ColumnNoCrop] Best', {cols: best.C, neededGap: +best.neededGap.toFixed(2), score: +best.score.toFixed(3)});
    } else {
      log('[ColumnNoCrop] No feasible partition');
    }
    return best;
  }

  function buildColumnPositions(best, W, H, hgap, vgap) {
    const C = best.C;
    const gap = C > 1 ? best.neededGap : 0; // 讓寬度總和精確鋪滿 W
    const positions = [];
    let globalIndex = 0;
    let x = 0;

    for (let j = 0; j < C; j++) {
      const col = best.cols[j];
      const w = best.widths[j];

      // 逐張由上而下
      let y = 0;
      for (let i = 0; i < col.count; i++) {
        const a = col.aspects[i];
        let h = w / a;

        // 最後一張用剩餘高消除浮點/分配誤差 → 滿高
        if (i === col.count - 1) {
          const used = col.aspects.slice(0, i).reduce((s, aa) => s + (w / aa), 0)
                       + vgap * Math.max(0, col.count - 1);
          h = Math.max(0, H - used);
        }

        positions.push({idx: globalIndex, x, y, width: w, height: h});
        y += h + vgap;
        globalIndex++;
      }
      x += w + (j < C - 1 ? gap : 0);
    }
    return positions;
  }

  // ---------- BalancedNoCrop（保留，作 row 方向後備/切換） ----------
  function balancedPartition(aspects, rows) {
    const idxs = aspects.map((_, i) => i).sort((a, b) => aspects[b] - aspects[a]);
    const sums = new Array(rows).fill(0);
    const buckets = new Array(rows).fill(0).map(() => []);
    for (const i of idxs) {
      let bi = 0, mn = sums[0];
      for (let r = 1; r < rows; r++) {
        if (sums[r] < mn) { mn = sums[r]; bi = r; }
      }
      buckets[bi].push(i);
      sums[bi] += aspects[i];
    }
    return buckets;
  }

  function computeRowHeights(buckets, aspects, W, hgap) {
    return buckets.map(row => {
      const S = row.reduce((s, i) => s + aspects[i], 0);
      const n = row.length;
      const innerW = W - hgap * Math.max(0, n - 1);
      return innerW / Math.max(1e-9, S);
    });
  }

  function scaleHeightsToH(heights, H, vgap) {
    const sumH = heights.reduce((s, v) => s + v, 0);
    const target = H - vgap * Math.max(0, heights.length - 1);
    const alpha = target / Math.max(1e-9, sumH);
    return heights.map(h => h * alpha);
  }

  function buildRowPositions(buckets, heights, aspects, W, hgap, vgap) {
    const pos = new Array(aspects.length);
    let y = 0;
    for (let r = 0; r < buckets.length; r++) {
      const row = buckets[r];
      const n = row.length;
      const h = heights[r];
      const innerW = W - hgap * Math.max(0, n - 1);
      const widths = row.map(i => aspects[i] * h);
      const beta = innerW / Math.max(1e-9, widths.reduce((s, v) => s + v, 0));
      let x = 0;
      for (let k = 0; k < n; k++) {
        const i = row[k];
        const w = widths[k] * beta;
        pos[i] = {x, y, width: w, height: h};
        x += w + hgap;
      }
      y += h + vgap;
    }
    return pos;
  }

  function solveBalancedNoCrop(aspects, W, H, hgap, vgap) {
    let best = null;
    for (let rows = 3; rows <= 6; rows++) {
      const buckets = balancedPartition(aspects, rows);
      if (buckets.some(b => b.length === 0)) continue;
      let heights = computeRowHeights(buckets, aspects, W, hgap);
      heights = scaleHeightsToH(heights, H, vgap);
      const pos = buildRowPositions(buckets, heights, aspects, W, hgap, vgap);
      const used = pos.reduce((s, p) => s + p.width * p.height, 0);
      const util = used / (W * H);
      const minH = Math.min(...heights), maxH = Math.max(...heights);
      const uniform = maxH - minH;
      const score = (1 - util) * 100 + uniform;
      if (!best || score < best.score) {
        best = {rows, pos, util, uniform, score};
      }
    }
    return best;
  }

  // ---------- Absolute placement ----------
  function place(root, imgs, positions) {
    root.style.position = 'relative';
    root.style.overflow = 'hidden';
    for (let p = 0; p < positions.length; p++) {
      const P = positions[p];
      const i = (P.idx != null) ? P.idx : p; // 支援兩種格式
      const el = imgs[i];
      const s = el.style;
      s.position = 'absolute';
      s.margin = '0'; s.padding = '0'; s.border = '0';
      s.maxWidth = 'none'; s.maxHeight = 'none';
      try { s.setProperty('object-fit', 'contain', 'important'); } catch(_) {}
      s.left = P.x + 'px';
      s.top  = P.y + 'px';
      s.width  = P.width + 'px';
      s.height = P.height + 'px';
    }
  }

  // ---------- Layout one box ----------
  function layoutBox(root) {
    const W = root.clientWidth;
    const H = root.clientHeight;
    const hgap = +root.dataset.hgap || +root.dataset.hGap || 4;
    const vgap = +root.dataset.vgap || +root.dataset.vGap || 4;
    const flow = (root.dataset.flow || 'row').toLowerCase(); // 'col' or 'row'
    const minCols = +root.dataset.mincols || 3;
    const maxCols = +root.dataset.maxcols || 6;

    const imgs = Array.from(root.querySelectorAll('img'));
    if (!imgs.length || W <= 0 || H <= 0) return;

    const aspects = imgs.map(img => {
      const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
      return (w > 0 && h > 0) ? w / h : 4 / 3;
    });

    if (flow === 'col' || flow === 'column' || flow === 'bycol') {
      log('[ColumnNoCrop] === 開始佈局 ===');
      const best = solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols);
      if (best) {
        const positions = buildColumnPositions(best, W, H, hgap, vgap);
        place(root, imgs, positions);
        log('[ColumnNoCrop] === 佈局完成 ===');
        return;
      }
      // 若無可行，回退 row
      log('[ColumnNoCrop] 無解，回退 BalancedNoCrop');
    }

    // Row fallback / 或 flow=row
    log('[BalancedNoCrop] === 開始佈局 ===');
    const sol = solveBalancedNoCrop(aspects, W, H, hgap, vgap);
    if (sol) {
      place(root, imgs, sol.pos);
      log('[BalancedNoCrop] Utilization', (sol.util * 100).toFixed(2) + '%');
      log('[BalancedNoCrop] === 佈局完成 ===');
    }
  }

  // ---------- Init ----------
  async function init(selector = '.' + CLASS) {
    const boxes = Array.from(document.querySelectorAll(selector));
    const roList = [];
    for (const root of boxes) {
      const imgs = Array.from(root.querySelectorAll('img'));
      await Promise.all(imgs.map(preload));
      await raf2();
      layoutBox(root);
      const ro = new ResizeObserver(() => layoutBox(root));
      ro.observe(root);
      roList.push(ro);
    }
    window.CollageModes = {
      relayout() { boxes.forEach(layoutBox); },
      disconnect() { roList.forEach(ro => ro.disconnect()); }
    };
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }
})();
</script>

</body>
</html>
