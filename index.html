<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Collage - No-Crop Column Flow + Balanced Row</title>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }

    /* Collage defaults: prevent clipping, keep images contained */
    .img_collage {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
    }
    .img_collage *,
    .img_collage img {
      box-sizing: border-box;
    }
    .img_collage img {
      object-fit: contain !important;
      object-position: center center !important;
      display: block;
      image-rendering: auto;
      -webkit-user-drag: none;
      user-select: none;
    }
  </style>
</head>
<body>

<h3>Image Collage - Fixed 640x500 (No Crop) — Column-first flow enabled</h3>

<!-- 說明：
  - data-flow="col" → 以「高度優先、由上到下，再由左到右」的欄式排法（滿高），適合 19/20 張等不等量
  - data-flow 可切換為 "row" → 使用 BalancedNoCrop 的等高列式排法（滿寬）
  - data-mincols / data-maxcols → 欄數搜尋範圍（欄式）
  - data-hgap / data-vgap → 欄間與圖間間距
  - data-minutil → 欄式利用率門檻（0~1，預設 0.88），低於門檻自動改用 row 方案以「自動補滿空白」
-->
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1025/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1043/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1003/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1024/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1027/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1028/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1029/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1031/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1032/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1033/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<script>
/*!
 * ColumnNoCrop v1.0 + BalancedNoCrop v4.0
 * - ColumnNoCrop（高度優先、欄式）：由上到下，再由左到右；每欄恰好填滿 H，不裁剪，不變形
 *   對 N=19/20 等不等量都穩定；自動搜索欄數與每欄張數分配，將橫向剩餘寬度分配到欄間距，避免水平留白帶來縫隙不齊
 * - BalancedNoCrop（寬度優先、列式）：滿寬、列高一致，已在前版驗證 >95% 利用率
 */
(function(){
  "use strict";
  const CLASS = "img_collage";

  // Debug config
  window.__COLLAGE_DEBUG = true;
  const DEBUG_ENABLED = !!window.__COLLAGE_DEBUG;
  const MAX_DEBUG_LINES = 500;

  // ---------- Debug Logger ----------
  function log(message, data) {
    if (DEBUG_ENABLED) {
      console.log(message, data ?? '');
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        const line = document.createElement('div');
        line.textContent = `${message} ${data !== undefined ? JSON.stringify(data) : ''}`;
        debugDiv.appendChild(line);
        // Trim debug lines to avoid DOM bloat
        while (debugDiv.childElementCount > MAX_DEBUG_LINES) {
          debugDiv.removeChild(debugDiv.firstChild);
        }
      }
    }
  }

  // ---------- Helpers ----------
  const raf2 = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Basic debounce to reduce layout thrashing on resize
  function debounce(fn, delay = 80) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  function preload(img){
    return new Promise(res=>{
      if (img.complete && img.naturalWidth>0) { res(); return; }
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    });
  }

  // Numeric parsing helpers (allow 0, clamp ranges)
  const EPS = 1e-6;
  function hasNumber(v){ return v !== undefined && v !== null && v !== '' && !Number.isNaN(+v); }
  function getDataNumber(ds, keys, def){
    if (!Array.isArray(keys)) keys = [keys];
    for (const k of keys) {
      if (hasNumber(ds[k])) return +ds[k];
    }
    return def;
  }
  function clampRange(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
  function clampNonNeg(x){ return Math.max(0, x); }
  function clampInt(x, lo, hi){
    const n = Math.round(+x);
    const v = Number.isFinite(n) ? n : lo;
    return Math.min(hi, Math.max(lo, v));
  }

  // ---------- ColumnNoCrop: compositions generator ----------
  function generateCompositions(n, k, cb, control) {
    // 產生 k 個正整數之組合，其和 = n；串流回呼避免大量內存
    control = control || {};
    const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();
    const deadline = Number.isFinite(control.deadline) ? control.deadline : Infinity;
    const limit = Number.isFinite(control.limit) ? control.limit : Infinity;
    let count = 0;

    function shouldStop() {
      if (count >= limit) { control.stopped = true; control.truncated = true; return true; }
      if (now() > deadline) { control.stopped = true; control.truncated = true; return true; }
      return false;
    }

    function rec(parts, left, slots) {
      if (control.stopped) return;
      if (slots === 1) {
        cb([...parts, left]);
        count++;
        if (shouldStop()) return;
        return;
      }
      const maxT = left - (slots - 1);
      for (let t = 1; t <= maxT; t++) {
        if (control.stopped) return;
        parts.push(t);
        rec(parts, left - t, slots - 1);
        parts.pop();
        if (control.stopped) return;
      }
    }
    rec([], n, k);
    control.count = count;
  }

  // ---------- ColumnNoCrop: solver ----------
  function solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH) {
    log('[ColumnNoCrop] Start', {W,H,N:aspects.length, minCols, maxCols});
    let best = null;

    // 計算可行欄數範圍：最多不超過 N；允許低於 minCols 以確保可解（例如 N 小或寬度不足時）
    const N = aspects.length;
    const cMax = Math.min(Math.max(minCols, maxCols), N);
    const cMin = 1;
    const nowFn = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();

    // 優先嘗試較多欄，若無可行則逐步降欄（避免負 gap）
    for (let C = cMax; C >= cMin; C--) {
      const ctrl = { limit: 200000, deadline: nowFn() + 12 };
      generateCompositions(N, C, (counts) => {
        // 依輸入順序：上到下 → 下一欄
        let idx = 0;
        const cols = [];
        const widths = [];

        let invalid = false;
        for (let j = 0; j < C; j++) {
          const cnt = counts[j];
          const list = aspects.slice(idx, idx + cnt);
          idx += cnt;

          const H_eff = H - vgap * Math.max(0, cnt - 1);
          if (H_eff <= 0) { invalid = true; break; }

          const Sj = list.reduce((s, a) => s + 1 / Math.max(1e-6, a), 0); // Σ(1/a)
          if (!(Sj > 1e-6) || !Number.isFinite(Sj)) { invalid = true; break; }

          const wj = H_eff / Math.max(1e-6, Sj); // 欄寬 wj，使 Σ(wj/a) + gaps = H → 滿高
          if (!(wj > 0) || !Number.isFinite(wj)) { invalid = true; break; }

          // minimal image height constraint for this column
          const maxA = list.reduce((m, a) => Math.max(m, Math.max(1e-6, a)), 1e-6);
          const minHCol = wj / maxA;
          if (Number.isFinite(minImgH) && minImgH > 0 && minHCol < minImgH) { invalid = true; break; }

          cols.push({ count: cnt, aspects: list });
          widths.push(wj);
        }
        if (invalid) { return; }

        const sumW = widths.reduce((s, v) => s + v, 0);
        const neededGap = (C > 1) ? (W - sumW) / (C - 1) : 0; // 讓總寬 + gap*(C-1) 精確 = W

        // 若 neededGap 為負，代表以滿高無法鋪滿寬度 → 此欄數不可行，跳過
        if (neededGap < -1e-6) {
          return;
        }

        // 打分：gap 接近期望值、欄寬均衡 + 更高利用率 + 列數偏好
        const meanW = sumW / C;
        const varW = widths.reduce((s, v) => s + (v - meanW) * (v - meanW), 0) / C;
        const usedArea = widths.reduce((s, w, j) => s + w * Math.max(0, H - vgap * Math.max(0, counts[j] - 1)), 0);
        const utilEst = usedArea / Math.max(1e-6, W * H);
        const colsPref = Math.abs(C - Math.max(2, Math.round(Math.sqrt(N))));
        const score = Math.abs(neededGap - hgap) * 2.5 + Math.sqrt(varW) * 0.7 + (1 - utilEst) * 80 + colsPref * 0.3;

        if (!best || score < best.score) {
          best = { C, counts, cols, widths, neededGap, sumW, score };
        }
      }, ctrl);

      if (ctrl.truncated) {
        log('[ColumnNoCrop] compositions truncated', { C, visited: ctrl.count });
      }

      // 若已找到可行解且 gap 非負，即可提前結束（偏好較多欄的可行解）
      if (best) break;
    }

    if (best) {
      log('[ColumnNoCrop] Best', { cols: best.C, neededGap: +best.neededGap.toFixed(2), score: +best.score.toFixed(3) });
    } else {
      log('[ColumnNoCrop] No feasible partition');
    }
    return best;
  }

  function buildColumnPositions(best, W, H, hgap, vgap) {
    const C = best.C;
    const gap = C > 1 ? best.neededGap : 0; // 讓寬度總和精確鋪滿 W
    const positions = [];
    let globalIndex = 0;
    let x = 0;

    for (let j = 0; j < C; j++) {
      const col = best.cols[j];
      const w = best.widths[j];

      // 逐張由上而下
      let y = 0;
      for (let i = 0; i < col.count; i++) {
        const a = col.aspects[i];
        const safeW = Math.max(0, w);
        let h = Math.max(0, safeW / Math.max(1e-6, a));

        // 保持原始比例，避免强制拉伸/压缩造成“伪裁剪”
        // 不在最后一张使用剩余高度消除误差；微小误差由底部留白吸收
        // h = safeW / a 已保证比例一致

        positions.push({idx: globalIndex, x, y, width: w, height: h});
        y += h + vgap;
        globalIndex++;
      }
      x += w + (j < C - 1 ? gap : 0);
    }
    return positions;
  }

  // ---------- Small-set visual layouts (N ≤ 4) ----------
  function buildSmallSetPositions(aspects, W, H, hgap, vgap) {
    const N = aspects.length;
    const pos = [];
    const innerW = (n) => W - hgap * Math.max(0, n - 1);
    const EPS2 = 1e-6;
    function pushIdx(idx, x, y, w, h){ pos.push({ idx, x, y, width: w, height: h }); }
    if (N === 1) {
      const a = Math.max(EPS2, aspects[0]);
      let w = W, h = W / a;
      if (h > H) { h = H; w = H * a; }
      const x = (W - w) / 2; const y = (H - h) / 2;
      pushIdx(0, Math.max(0,x), Math.max(0,y), Math.max(0,w), Math.max(0,h));
      return pos;
    }
    if (N === 2) {
      const iw = innerW(2);
      const sA = Math.max(EPS2, aspects[0] + aspects[1]);
      const h = iw / sA;
      const top = Math.max(0, (H - h) / 2);
      const w0 = aspects[0] * h; const w1 = aspects[1] * h;
      pushIdx(0, 0, top, w0, h);
      pushIdx(1, w0 + hgap, top, w1, h);
      return pos;
    }
    if (N === 3) {
      const combos = [ [0,1,2], [0,2,1], [1,2,0] ];
      let best = null;
      for (const [i,j,k] of combos) {
        const iw1 = innerW(2), iw2 = innerW(1);
        const h1 = iw1 / Math.max(EPS2, aspects[i] + aspects[j]);
        const h2 = iw2 / Math.max(EPS2, aspects[k]);
        const alpha = (H - vgap) / Math.max(EPS2, h1 + h2);
        const H1 = h1 * alpha, H2 = h2 * alpha;
        const score = Math.abs(H1 - H2);
        if (!best || score < best.score) best = {i,j,k,H1,H2,score};
      }
      const {i,j,k,H1,H2} = best;
      let x = 0; const y1 = 0;
      const w_i = aspects[i] * H1; pushIdx(i, x, y1, w_i, H1); x += w_i + hgap;
      const w_j = aspects[j] * H1; pushIdx(j, x, y1, w_j, H1);
      const w_k = aspects[k] * H2; const xk = (W - w_k) / 2; const y2 = H1 + vgap;
      pushIdx(k, Math.max(0,xk), y2, w_k, H2);
      return pos;
    }
    if (N === 4) {
      const pairs = [ [ [0,1],[2,3] ], [ [0,2],[1,3] ], [ [0,3],[1,2] ] ];
      let best = null;
      for (const [[a,b],[c,d]] of pairs) {
        const s1 = aspects[a] + aspects[b];
        const s2 = aspects[c] + aspects[d];
        const diff = Math.abs(s1 - s2);
        if (!best || diff < best.diff) best = {rows:[[a,b],[c,d]], s1, s2, diff};
      }
      const [[r1a, r1b],[r2a, r2b]] = best.rows;
      const iw = innerW(2);
      const h1 = iw / Math.max(EPS2, aspects[r1a] + aspects[r1b]);
      const h2 = iw / Math.max(EPS2, aspects[r2a] + aspects[r2b]);
      const alpha = (H - vgap) / Math.max(EPS2, h1 + h2);
      const H1 = h1 * alpha, H2 = h2 * alpha;
      let x1 = 0; const y1 = 0;
      const w1a = aspects[r1a] * H1; pushIdx(r1a, x1, y1, w1a, H1); x1 += w1a + hgap;
      const w1b = aspects[r1b] * H1; pushIdx(r1b, x1, y1, w1b, H1);
      let x2 = 0; const y2 = H1 + vgap;
      const w2a = aspects[r2a] * H2; pushIdx(r2a, x2, y2, w2a, H2); x2 += w2a + hgap;
      const w2b = aspects[r2b] * H2; pushIdx(r2b, x2, y2, w2b, H2);
      return pos;
    }
    return pos;
  }
  
  // ---------- BalancedNoCrop（保留，作 row 方向後備/切換） ----------
  function balancedPartition(aspects, rows) {
    const idxs = aspects.map((_, i) => i).sort((a, b) => aspects[b] - aspects[a]);
    const sums = new Array(rows).fill(0);
    const buckets = new Array(rows).fill(0).map(() => []);
    for (const i of idxs) {
      let bi = 0, mn = sums[0];
      for (let r = 1; r < rows; r++) {
        if (sums[r] < mn) { mn = sums[r]; bi = r; }
      }
      buckets[bi].push(i);
      sums[bi] += aspects[i];
    }
    return buckets;
  }

  function computeRowHeights(buckets, aspects, W, hgap) {
    return buckets.map(row => {
      const S = row.reduce((s, i) => s + aspects[i], 0);
      const n = row.length;
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      return innerW / Math.max(1e-6, S);
    });
  }

  function scaleHeightsToH(heights, H, vgap) {
    const sumH = heights.reduce((s, v) => s + v, 0);
    const target = H - vgap * Math.max(0, heights.length - 1);
    const alpha = target / Math.max(1e-6, sumH);
    return heights.map(h => h * alpha);
  }

  function buildRowPositions(buckets, heights, aspects, W, hgap, vgap) {
    const pos = new Array(aspects.length);
    let y = 0;
    for (let r = 0; r < buckets.length; r++) {
      const row = buckets[r];
      const n = row.length;
      const h = heights[r];
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      const widths = row.map(i => Math.max(1e-6, aspects[i]) * h);
      const beta = innerW / Math.max(1e-6, widths.reduce((s, v) => s + v, 0));
      let x = 0;
      for (let k = 0; k < n; k++) {
        const i = row[k];
        const w = widths[k] * beta;
        pos[i] = {x, y, width: w, height: h};
        x += w + hgap;
      }
      y += h + vgap;
    }
    return pos;
  }

  // Mosaic variant: per-image variable heights within a row (no-crop), portrait-friendly.
  // - jitter: 0..1 random variation around base height per image
  // - pboost: 0..1 extra boost for portrait (a<1) to gain more height
  // - align: 'center' | 'top' vertical alignment inside row block
  function buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, opts) {
    const jitter = Math.max(0, Math.min(1, (opts && +opts.jitter) || 0.12));
    const pboost = Math.max(0, Math.min(1, (opts && +opts.pboost) || 0.15));
    const align = (opts && opts.align) || 'center';
    function sRand(seed) { const x = Math.sin(seed) * 43758.5453123; return x - Math.floor(x); }

    let scales = new Array(buckets.length).fill(1);
    let positions = new Array(aspects.length);

    // Fixed-point like refinement to exactly fill total H
    for (let iter = 0; iter < 3; iter++) {
      positions = new Array(aspects.length);
      let y = 0;
      const blockHeights = [];

      for (let r = 0; r < buckets.length; r++) {
        const row = buckets[r];
        const n = row.length;
        const baseH = heights[r] * scales[r];
        const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));

        // Per-image factors (stable pseudo-random + portrait boost)
        const factors = [];
        for (let k = 0; k < n; k++) {
          const i = row[k];
          let f = 1 + (sRand(i * 97 + r * 131) - 0.5) * 2 * jitter;
          if (aspects[i] < 1) f += pboost;
          f = Math.max(0.6, Math.min(1.6, f));
          factors.push(f);
        }

        // Normalize to fit row width
        const sumW = row.reduce((s, i, k) => s + aspects[i] * baseH * factors[k], 0);
        const gamma = innerW / Math.max(1e-6, sumW);

        // Compute per-image sizes and row block height
        const heightsI = factors.map(f => baseH * f * gamma);
        const rowBlockH = Math.max(...heightsI);

        let x = 0;
        for (let k = 0; k < n; k++) {
          const i = row[k];
          const h_i = heightsI[k];
          const w_i = aspects[i] * h_i;
          let top = y;
          if (align === 'center') top = y + (rowBlockH - h_i) / 2;
          positions[i] = { x, y: top, width: w_i, height: h_i };
          x += w_i + hgap;
        }

        blockHeights[r] = rowBlockH;
        y += rowBlockH + vgap;
      }

      const totalH = blockHeights.reduce((s, v) => s + v, 0) + vgap * Math.max(0, blockHeights.length - 1);
      const targetH = (opts && opts.targetH) || 0;
      const scaleAlpha = targetH ? targetH / Math.max(1e-6, totalH) : 1;
      // Early stop when within sub-pixel tolerance
      if (targetH && Math.abs(totalH - targetH) <= 0.5) {
        break;
      }
      scales = scales.map(s => s * scaleAlpha);
    }

    return positions;
  }

  function solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts) {
    let best = null;
    const N2 = aspects.length;
    const sqrtN = Math.max(2, Math.round(Math.sqrt(N2)));
    const rowsMin = Math.max(2, sqrtN - 1);
    const rowsMax = Math.min(8, sqrtN + 2);
    for (let rows = rowsMin; rows <= rowsMax; rows++) {
      const buckets = balancedPartition(aspects, rows);
      if (buckets.some(b => b.length === 0)) continue;

      let heights = computeRowHeights(buckets, aspects, W, hgap);
      heights = scaleHeightsToH(heights, H, vgap);

      // Use mosaic (per-image variable height) when requested
      const pos = (opts && opts.mosaic)
        ? buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, { jitter: opts.jitter, pboost: opts.pboost, align: opts.align, targetH: H })
        : buildRowPositions(buckets, heights, aspects, W, hgap, vgap);

      const used = pos.reduce((s, p) => s + p.width * p.height, 0);
      const util = used / (W * H);
      const minH = Math.min(...heights), maxH = Math.max(...heights);
      const uniform = maxH - minH;
      const rowsPref = Math.abs(rows - sqrtN);
      const score = (1 - util) * 120 + uniform * 0.6 + rowsPref * 0.5;
      if (!best || score < best.score) {
        best = { rows, pos, util, uniform, score };
      }
    }
    return best;
  }

  // ---------- Absolute placement ----------
  function place(root, imgs, positions) {
    root.style.position = 'relative';
    root.style.overflow = 'hidden';
    const animate = ((root.dataset.animate || 'true') + '').toLowerCase() !== 'false';
    const first = !root.__laid;
    for (let p = 0; p < positions.length; p++) {
      const P = positions[p];
      const i = (P.idx != null) ? P.idx : p; // 支援兩種格式
      const el = imgs[i];
      const s = el.style;
      s.position = 'absolute';
      s.margin = '0'; s.padding = '0'; s.border = '0';
      s.maxWidth = 'none'; s.maxHeight = 'none';
      try { s.setProperty('object-fit', 'contain', 'important'); } catch(_) {}
      try { s.setProperty('object-position', 'center center', 'important'); } catch(_) {}
      // Smooth transitions only after first layout
      if (animate && !first) {
        s.transition = 'left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease';
        s.willChange = 'left, top, width, height';
      } else {
        s.transition = 'none';
        s.willChange = '';
      }
      s.left = P.x + 'px';
      s.top  = P.y + 'px';
      s.width  = P.width + 'px';
      s.height = P.height + 'px';
    }
    // Debug: log first 10 tiles' box sizes vs natural aspect when enabled
    if (DEBUG_ENABLED && window.__COLLAGE_LOG_TILES) {
      const cap = Math.min(10, positions.length);
      for (let p = 0; p < cap; p++) {
        const P = positions[p];
        const i = (P.idx != null) ? P.idx : p;
        const iw = imgs[i].naturalWidth || 0, ih = imgs[i].naturalHeight || 0;
        const imgAR = ih > 0 ? iw / ih : 0;
        const boxAR = P.height > 0 ? P.width / P.height : 0;
        const boxW = +(P.width).toFixed(2);
        const boxH = +(P.height).toFixed(2);
        const boxARf = +(boxAR).toFixed(3);
        const imgARf = +(imgAR).toFixed(3);
        log('[Tile]', { idx: i, boxW, boxH, boxAR: boxARf, imgAR: imgARf });
      }
    }
    root.__laid = true;
  }

  // ---------- Layout one box ----------
  function layoutBox(root) {
    const W = root.clientWidth;
    const H = root.clientHeight;
    const flow = (root.dataset.flow || 'auto').toLowerCase(); // 'auto' | 'col' | 'row'
    const imgsCount = root.querySelectorAll('img').length;
    const defGap = imgsCount > 20 ? 2 : 4;
    const minUtil = clampRange(getDataNumber(root.dataset, ['minutil'], 0.88), 0, 1); // 利用率門檻（預設 0.88）
    const minImgH = clampNonNeg(getDataNumber(root.dataset, ['minimg','minimageheight'], 24));

    const autoCols = (function(){
      const N = imgsCount;
      if (N <= 2) return {min: N, max: N};
      if (N <= 4) return {min: 2, max: 3};
      if (N <= 7) return {min: 3, max: 4};
      if (N <= 12) return {min: 3, max: 6};
      if (N <= 20) return {min: 4, max: 7};
      return {min: 4, max: 8};
    })();

    const minCols = clampInt(getDataNumber(root.dataset, ['mincols'], autoCols.min), 1, 99);
    const maxCols = clampInt(getDataNumber(root.dataset, ['maxcols'], autoCols.max), 1, 99);
    const hgap = clampNonNeg(getDataNumber(root.dataset, ['hgap','hGap'], defGap));
    const vgap = clampNonNeg(getDataNumber(root.dataset, ['vgap','vGap'], defGap));
    // Dynamic minUtil threshold based on collection size
    let effMinUtil = minUtil;
    if (imgsCount > 30) effMinUtil = Math.max(effMinUtil, 0.94);
    else if (imgsCount > 16) effMinUtil = Math.max(effMinUtil, 0.92);

    const imgs = Array.from(root.querySelectorAll('img'));
    if (!imgs.length || W <= 0 || H <= 0) return;

    const aspects = imgs.map(img => {
      let a = hasNumber(img.dataset.aspect) ? +img.dataset.aspect : NaN;
      if (!(a > 0)) {
        const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
        a = (w > 0 && h > 0) ? (w / h) : 4 / 3;
        try { img.dataset.aspect = String(a); } catch (_) {}
      }
      return a;
    });

    // Small set visual rules for N ≤ 4
    const Nsmall = aspects.length;
    if (Nsmall <= 4) {
      const positionsSmall = buildSmallSetPositions(aspects, W, H, hgap, vgap);
      place(root, imgs, positionsSmall);
      log('[SmallSet] layout used', { N: Nsmall });
      return;
    }
  
    if (flow === 'col' || flow === 'column' || flow === 'bycol' || flow === 'auto') {
      log('[ColumnNoCrop] === 開始佈局 ===');
      const best = solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols, minImgH);
      if (best) {
        const positions = buildColumnPositions(best, W, H, hgap, vgap);
        const used = positions.reduce((s, p) => s + p.width * p.height, 0);
        const util = used / (W * H);
        log('[ColumnNoCrop] Utilization', (util * 100).toFixed(2) + '%');

        // 若欄式利用率太低 → 自動改用 row 方案以補滿空白
        if (util >= effMinUtil) {
          place(root, imgs, positions);
          log('[ColumnNoCrop] === 佈局完成 ===');
          return;
        } else {
          log('[ColumnNoCrop] 利用率低於門檻，回退 BalancedNoCrop', {minUtil: effMinUtil});
        }
      } else {
        // 若無可行，回退 row
        log('[ColumnNoCrop] 無解，回退 BalancedNoCrop');
      }
    }

    // Row fallback / 或 flow=row
    log('[BalancedNoCrop] === 開始佈局 ===');
    const style = (root.dataset.style || '').toLowerCase();
    let jitter = getDataNumber(root.dataset, ['jitter'], NaN);
    let pboost = getDataNumber(root.dataset, ['portraitboost'], NaN);

    // Auto mosaic decision when style is not specified
    let mosaicAuto = false;
    if (!style) {
      const aMin = Math.min(...aspects);
      const aMax = Math.max(...aspects);
      const variety = aMax / Math.max(1e-6, aMin);
      const portraitShare = aspects.filter(a => a < 1).length / aspects.length;
      mosaicAuto = variety > 2.0 || portraitShare > 0.30;
    }
    const useMosaic = (style === 'mosaic') || mosaicAuto || (hasNumber(jitter) && jitter > 0);

    // Defaults when not provided
    if (!hasNumber(jitter)) jitter = useMosaic ? 0.12 : 0;
    if (!hasNumber(pboost)) pboost = useMosaic ? 0.15 : 0;

    const opts = { mosaic: useMosaic, jitter: clampRange(jitter, 0, 1), pboost: clampRange(pboost, 0, 1), align: 'center' };
    const sol = solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts);
    if (sol) {
      place(root, imgs, sol.pos);
      log('[BalancedNoCrop] Utilization', (sol.util * 100).toFixed(2) + '%');
      log('[BalancedNoCrop] === 佈局完成 ===');
    }
  }

  // ---------- Init ----------
  async function init(selector = '.' + CLASS) {
    // Hide debug panel unless explicitly enabled
    const dbg = document.getElementById('debugInfo');
    if (dbg && !DEBUG_ENABLED) { dbg.style.display = 'none'; }

    const boxes = Array.from(document.querySelectorAll(selector));
    const roList = [];
    for (const root of boxes) {
      const imgs = Array.from(root.querySelectorAll('img'));
      await Promise.all(imgs.map(preload));
      await raf2();
      layoutBox(root);
      const debouncedLayout = debounce(() => layoutBox(root), 80);
      const ro = new ResizeObserver(debouncedLayout);
      ro.observe(root);
      roList.push(ro);
    }
    window.CollageModes = {
      relayout() { boxes.forEach(layoutBox); },
      disconnect() { roList.forEach(ro => ro.disconnect()); }
    };

    // Auto cleanup observers on page lifecycle end
    try {
      window.addEventListener('pagehide', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
      window.addEventListener('beforeunload', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
    } catch(_) {}

  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }
})();
</script>

</body>
</html>
