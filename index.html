<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Collage - No-Crop Column Flow + Balanced Row</title>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>

<h3>Image Collage - Fixed 640x500 (No Crop) — Column-first flow enabled</h3>

<!-- 說明：
  - data-flow="col" → 以「高度優先、由上到下，再由左到右」的欄式排法（滿高），適合 19/20 張等不等量
  - data-flow 可切換為 "row" → 使用 BalancedNoCrop 的等高列式排法（滿寬）
  - data-mincols / data-maxcols → 欄數搜尋範圍（欄式）
  - data-hgap / data-vgap → 欄間與圖間間距
  - data-minutil → 欄式利用率門檻（0~1，預設 0.88），低於門檻自動改用 row 方案以「自動補滿空白」
-->
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
</div>
<div
  class="img_collage"
  style="width:640px;height:500px;border:2px solid #333;background:#fafafa;"
  data-flow="col"
  data-mincols="3"
  data-maxcols="6"
  data-hgap="4"
  data-vgap="4"
  data-style="mosaic"
  data-jitter="0.18"
  data-portraitboost="0.25"
>
  <img src="https://picsum.photos/id/1015/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1018/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1019/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1020/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1041/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1021/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1025/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1043/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1003/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1024/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1027/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1028/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1029/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1031/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1032/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1033/800/1200.jpg"   alt="">
  <img src="https://picsum.photos/id/1035/1181/1772.jpg"  alt="">
  <img src="https://picsum.photos/id/1036/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1037/1200/800.jpg"  alt="">
  <img src="https://picsum.photos/id/1040/800/1200.jpg"   alt="">
</div>

<div class="debug-info" id="debugInfo">Debug info will appear here...</div>

<script>
/*!
 * ColumnNoCrop v1.0 + BalancedNoCrop v4.0
 * - ColumnNoCrop（高度優先、欄式）：由上到下，再由左到右；每欄恰好填滿 H，不裁剪，不變形
 *   對 N=19/20 等不等量都穩定；自動搜索欄數與每欄張數分配，將橫向剩餘寬度分配到欄間距，避免水平留白帶來縫隙不齊
 * - BalancedNoCrop（寬度優先、列式）：滿寬、列高一致，已在前版驗證 >95% 利用率
 */
(function(){
  "use strict";
  const CLASS = "img_collage";

  // Debug config
  const DEBUG_ENABLED = !!window.__COLLAGE_DEBUG;
  const MAX_DEBUG_LINES = 500;

  // ---------- Debug Logger ----------
  function log(message, data) {
    if (DEBUG_ENABLED) {
      console.log(message, data ?? '');
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        const line = document.createElement('div');
        line.textContent = `${message} ${data !== undefined ? JSON.stringify(data) : ''}`;
        debugDiv.appendChild(line);
        // Trim debug lines to avoid DOM bloat
        while (debugDiv.childElementCount > MAX_DEBUG_LINES) {
          debugDiv.removeChild(debugDiv.firstChild);
        }
      }
    }
  }

  // ---------- Helpers ----------
  const raf2 = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Basic debounce to reduce layout thrashing on resize
  function debounce(fn, delay = 80) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  function preload(img){
    return new Promise(res=>{
      if (img.complete && img.naturalWidth>0) { res(); return; }
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    });
  }

  // Numeric parsing helpers (allow 0, clamp ranges)
  const EPS = 1e-6;
  function hasNumber(v){ return v !== undefined && v !== null && v !== '' && !Number.isNaN(+v); }
  function getDataNumber(ds, keys, def){
    if (!Array.isArray(keys)) keys = [keys];
    for (const k of keys) {
      if (hasNumber(ds[k])) return +ds[k];
    }
    return def;
  }
  function clampRange(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
  function clampNonNeg(x){ return Math.max(0, x); }
  function clampInt(x, lo, hi){
    const n = Math.round(+x);
    const v = Number.isFinite(n) ? n : lo;
    return Math.min(hi, Math.max(lo, v));
  }

  // ---------- ColumnNoCrop: compositions generator ----------
  function generateCompositions(n, k, cb, control) {
    // 產生 k 個正整數之組合，其和 = n；串流回呼避免大量內存
    control = control || {};
    const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();
    const deadline = Number.isFinite(control.deadline) ? control.deadline : Infinity;
    const limit = Number.isFinite(control.limit) ? control.limit : Infinity;
    let count = 0;

    function shouldStop() {
      if (count >= limit) { control.stopped = true; control.truncated = true; return true; }
      if (now() > deadline) { control.stopped = true; control.truncated = true; return true; }
      return false;
    }

    function rec(parts, left, slots) {
      if (control.stopped) return;
      if (slots === 1) {
        cb([...parts, left]);
        count++;
        if (shouldStop()) return;
        return;
      }
      const maxT = left - (slots - 1);
      for (let t = 1; t <= maxT; t++) {
        if (control.stopped) return;
        parts.push(t);
        rec(parts, left - t, slots - 1);
        parts.pop();
        if (control.stopped) return;
      }
    }
    rec([], n, k);
    control.count = count;
  }

  // ---------- ColumnNoCrop: solver ----------
  function solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols) {
    log('[ColumnNoCrop] Start', {W,H,N:aspects.length, minCols, maxCols});
    let best = null;

    // 計算可行欄數範圍：最多不超過 N；允許低於 minCols 以確保可解（例如 N 小或寬度不足時）
    const N = aspects.length;
    const cMax = Math.min(Math.max(minCols, maxCols), N);
    const cMin = 1;
    const nowFn = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();

    // 優先嘗試較多欄，若無可行則逐步降欄（避免負 gap）
    for (let C = cMax; C >= cMin; C--) {
      const ctrl = { limit: 200000, deadline: nowFn() + 12 };
      generateCompositions(N, C, (counts) => {
        // 依輸入順序：上到下 → 下一欄
        let idx = 0;
        const cols = [];
        const widths = [];

        let invalid = false;
        for (let j = 0; j < C; j++) {
          const cnt = counts[j];
          const list = aspects.slice(idx, idx + cnt);
          idx += cnt;

          const H_eff = H - vgap * Math.max(0, cnt - 1);
          if (H_eff <= 0) { invalid = true; break; }

          const Sj = list.reduce((s, a) => s + 1 / Math.max(1e-6, a), 0); // Σ(1/a)
          if (!(Sj > 1e-6) || !Number.isFinite(Sj)) { invalid = true; break; }

          const wj = H_eff / Math.max(1e-6, Sj); // 欄寬 wj，使 Σ(wj/a) + gaps = H → 滿高
          if (!(wj > 0) || !Number.isFinite(wj)) { invalid = true; break; }

          cols.push({ count: cnt, aspects: list });
          widths.push(wj);
        }
        if (invalid) { return; }

        const sumW = widths.reduce((s, v) => s + v, 0);
        const neededGap = (C > 1) ? (W - sumW) / (C - 1) : 0; // 讓總寬 + gap*(C-1) 精確 = W

        // 若 neededGap 為負，代表以滿高無法鋪滿寬度 → 此欄數不可行，跳過
        if (neededGap < -1e-6) {
          return;
        }

        // 打分：gap 接近期望值、欄寬均衡
        const meanW = sumW / C;
        const varW = widths.reduce((s, v) => s + (v - meanW) * (v - meanW), 0) / C;
        const score = Math.abs(neededGap - hgap) * 3 + Math.sqrt(varW);

        if (!best || score < best.score) {
          best = { C, counts, cols, widths, neededGap, sumW, score };
        }
      }, ctrl);

      if (ctrl.truncated) {
        log('[ColumnNoCrop] compositions truncated', { C, visited: ctrl.count });
      }

      // 若已找到可行解且 gap 非負，即可提前結束（偏好較多欄的可行解）
      if (best) break;
    }

    if (best) {
      log('[ColumnNoCrop] Best', { cols: best.C, neededGap: +best.neededGap.toFixed(2), score: +best.score.toFixed(3) });
    } else {
      log('[ColumnNoCrop] No feasible partition');
    }
    return best;
  }

  function buildColumnPositions(best, W, H, hgap, vgap) {
    const C = best.C;
    const gap = C > 1 ? best.neededGap : 0; // 讓寬度總和精確鋪滿 W
    const positions = [];
    let globalIndex = 0;
    let x = 0;

    for (let j = 0; j < C; j++) {
      const col = best.cols[j];
      const w = best.widths[j];

      // 逐張由上而下
      let y = 0;
      for (let i = 0; i < col.count; i++) {
        const a = col.aspects[i];
        const safeW = Math.max(0, w);
        let h = Math.max(0, safeW / Math.max(1e-6, a));

        // 最後一張用剩餘高消除浮點/分配誤差 → 滿高
        if (i === col.count - 1) {
          const used = col.aspects.slice(0, i).reduce((s, aa) => s + Math.max(0, safeW / Math.max(1e-6, aa)), 0)
                       + vgap * Math.max(0, col.count - 1);
          h = Math.max(0, H - used);
        }

        positions.push({idx: globalIndex, x, y, width: w, height: h});
        y += h + vgap;
        globalIndex++;
      }
      x += w + (j < C - 1 ? gap : 0);
    }
    return positions;
  }

  // ---------- BalancedNoCrop（保留，作 row 方向後備/切換） ----------
  function balancedPartition(aspects, rows) {
    const idxs = aspects.map((_, i) => i).sort((a, b) => aspects[b] - aspects[a]);
    const sums = new Array(rows).fill(0);
    const buckets = new Array(rows).fill(0).map(() => []);
    for (const i of idxs) {
      let bi = 0, mn = sums[0];
      for (let r = 1; r < rows; r++) {
        if (sums[r] < mn) { mn = sums[r]; bi = r; }
      }
      buckets[bi].push(i);
      sums[bi] += aspects[i];
    }
    return buckets;
  }

  function computeRowHeights(buckets, aspects, W, hgap) {
    return buckets.map(row => {
      const S = row.reduce((s, i) => s + aspects[i], 0);
      const n = row.length;
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      return innerW / Math.max(1e-6, S);
    });
  }

  function scaleHeightsToH(heights, H, vgap) {
    const sumH = heights.reduce((s, v) => s + v, 0);
    const target = H - vgap * Math.max(0, heights.length - 1);
    const alpha = target / Math.max(1e-6, sumH);
    return heights.map(h => h * alpha);
  }

  function buildRowPositions(buckets, heights, aspects, W, hgap, vgap) {
    const pos = new Array(aspects.length);
    let y = 0;
    for (let r = 0; r < buckets.length; r++) {
      const row = buckets[r];
      const n = row.length;
      const h = heights[r];
      const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));
      const widths = row.map(i => Math.max(1e-6, aspects[i]) * h);
      const beta = innerW / Math.max(1e-6, widths.reduce((s, v) => s + v, 0));
      let x = 0;
      for (let k = 0; k < n; k++) {
        const i = row[k];
        const w = widths[k] * beta;
        pos[i] = {x, y, width: w, height: h};
        x += w + hgap;
      }
      y += h + vgap;
    }
    return pos;
  }

  // Mosaic variant: per-image variable heights within a row (no-crop), portrait-friendly.
  // - jitter: 0..1 random variation around base height per image
  // - pboost: 0..1 extra boost for portrait (a<1) to gain more height
  // - align: 'center' | 'top' vertical alignment inside row block
  function buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, opts) {
    const jitter = Math.max(0, Math.min(1, (opts && +opts.jitter) || 0.12));
    const pboost = Math.max(0, Math.min(1, (opts && +opts.pboost) || 0.15));
    const align = (opts && opts.align) || 'center';
    function sRand(seed) { const x = Math.sin(seed) * 43758.5453123; return x - Math.floor(x); }

    let scales = new Array(buckets.length).fill(1);
    let positions = new Array(aspects.length);

    // Fixed-point like refinement to exactly fill total H
    for (let iter = 0; iter < 3; iter++) {
      positions = new Array(aspects.length);
      let y = 0;
      const blockHeights = [];

      for (let r = 0; r < buckets.length; r++) {
        const row = buckets[r];
        const n = row.length;
        const baseH = heights[r] * scales[r];
        const innerW = Math.max(1e-6, W - hgap * Math.max(0, n - 1));

        // Per-image factors (stable pseudo-random + portrait boost)
        const factors = [];
        for (let k = 0; k < n; k++) {
          const i = row[k];
          let f = 1 + (sRand(i * 97 + r * 131) - 0.5) * 2 * jitter;
          if (aspects[i] < 1) f += pboost;
          f = Math.max(0.6, Math.min(1.6, f));
          factors.push(f);
        }

        // Normalize to fit row width
        const sumW = row.reduce((s, i, k) => s + aspects[i] * baseH * factors[k], 0);
        const gamma = innerW / Math.max(1e-6, sumW);

        // Compute per-image sizes and row block height
        const heightsI = factors.map(f => baseH * f * gamma);
        const rowBlockH = Math.max(...heightsI);

        let x = 0;
        for (let k = 0; k < n; k++) {
          const i = row[k];
          const h_i = heightsI[k];
          const w_i = aspects[i] * h_i;
          let top = y;
          if (align === 'center') top = y + (rowBlockH - h_i) / 2;
          positions[i] = { x, y: top, width: w_i, height: h_i };
          x += w_i + hgap;
        }

        blockHeights[r] = rowBlockH;
        y += rowBlockH + vgap;
      }

      const totalH = blockHeights.reduce((s, v) => s + v, 0) + vgap * Math.max(0, blockHeights.length - 1);
      const targetH = (opts && opts.targetH) || 0;
      const scaleAlpha = targetH ? targetH / Math.max(1e-6, totalH) : 1;
      // Early stop when within sub-pixel tolerance
      if (targetH && Math.abs(totalH - targetH) <= 0.5) {
        break;
      }
      scales = scales.map(s => s * scaleAlpha);
    }

    return positions;
  }

  function solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts) {
    let best = null;
    for (let rows = 3; rows <= 6; rows++) {
      const buckets = balancedPartition(aspects, rows);
      if (buckets.some(b => b.length === 0)) continue;

      let heights = computeRowHeights(buckets, aspects, W, hgap);
      heights = scaleHeightsToH(heights, H, vgap);

      // Use mosaic (per-image variable height) when requested
      const pos = (opts && opts.mosaic)
        ? buildRowPositionsMosaic(buckets, heights, aspects, W, hgap, vgap, { jitter: opts.jitter, pboost: opts.pboost, align: opts.align, targetH: H })
        : buildRowPositions(buckets, heights, aspects, W, hgap, vgap);

      const used = pos.reduce((s, p) => s + p.width * p.height, 0);
      const util = used / (W * H);
      const minH = Math.min(...heights), maxH = Math.max(...heights);
      const uniform = maxH - minH;
      const score = (1 - util) * 100 + uniform;
      if (!best || score < best.score) {
        best = { rows, pos, util, uniform, score };
      }
    }
    return best;
  }

  // ---------- Absolute placement ----------
  function place(root, imgs, positions) {
    root.style.position = 'relative';
    root.style.overflow = 'hidden';
    for (let p = 0; p < positions.length; p++) {
      const P = positions[p];
      const i = (P.idx != null) ? P.idx : p; // 支援兩種格式
      const el = imgs[i];
      const s = el.style;
      s.position = 'absolute';
      s.margin = '0'; s.padding = '0'; s.border = '0';
      s.maxWidth = 'none'; s.maxHeight = 'none';
      try { s.setProperty('object-fit', 'contain', 'important'); } catch(_) {}
      s.left = P.x + 'px';
      s.top  = P.y + 'px';
      s.width  = P.width + 'px';
      s.height = P.height + 'px';
    }
  }

  // ---------- Layout one box ----------
  function layoutBox(root) {
    const W = root.clientWidth;
    const H = root.clientHeight;
    const hgap = clampNonNeg(getDataNumber(root.dataset, ['hgap','hGap'], 4));
    const vgap = clampNonNeg(getDataNumber(root.dataset, ['vgap','vGap'], 4));
    const flow = (root.dataset.flow || 'row').toLowerCase(); // 'col' or 'row'
    const minCols = clampInt(getDataNumber(root.dataset, ['mincols'], 3), 1, 99);
    const maxCols = clampInt(getDataNumber(root.dataset, ['maxcols'], 6), 1, 99);
    const minUtil = clampRange(getDataNumber(root.dataset, ['minutil'], 0.88), 0, 1); // 利用率門檻（預設 0.88）

    const imgs = Array.from(root.querySelectorAll('img'));
    if (!imgs.length || W <= 0 || H <= 0) return;

    const aspects = imgs.map(img => {
      let a = hasNumber(img.dataset.aspect) ? +img.dataset.aspect : NaN;
      if (!(a > 0)) {
        const w = img.naturalWidth || 0, h = img.naturalHeight || 0;
        a = (w > 0 && h > 0) ? (w / h) : 4 / 3;
        try { img.dataset.aspect = String(a); } catch (_) {}
      }
      return a;
    });

    if (flow === 'col' || flow === 'column' || flow === 'bycol') {
      log('[ColumnNoCrop] === 開始佈局 ===');
      const best = solveColumnNoCrop(aspects, W, H, hgap, vgap, minCols, maxCols);
      if (best) {
        const positions = buildColumnPositions(best, W, H, hgap, vgap);
        const used = positions.reduce((s, p) => s + p.width * p.height, 0);
        const util = used / (W * H);
        log('[ColumnNoCrop] Utilization', (util * 100).toFixed(2) + '%');

        // 若欄式利用率太低 → 自動改用 row 方案以補滿空白
        if (util >= minUtil) {
          place(root, imgs, positions);
          log('[ColumnNoCrop] === 佈局完成 ===');
          return;
        } else {
          log('[ColumnNoCrop] 利用率低於門檻，回退 BalancedNoCrop', {minUtil});
        }
      } else {
        // 若無可行，回退 row
        log('[ColumnNoCrop] 無解，回退 BalancedNoCrop');
      }
    }

    // Row fallback / 或 flow=row
    log('[BalancedNoCrop] === 開始佈局 ===');
    const style = (root.dataset.style || '').toLowerCase();
    const jitter = clampRange(getDataNumber(root.dataset, ['jitter'], 0), 0, 1);
    const pboost = clampRange(getDataNumber(root.dataset, ['portraitboost'], 0), 0, 1);
    const opts = { mosaic: style === 'mosaic' || jitter > 0, jitter, pboost, align: 'center' };
    const sol = solveBalancedNoCrop(aspects, W, H, hgap, vgap, opts);
    if (sol) {
      place(root, imgs, sol.pos);
      log('[BalancedNoCrop] Utilization', (sol.util * 100).toFixed(2) + '%');
      log('[BalancedNoCrop] === 佈局完成 ===');
    }
  }

  // ---------- Init ----------
  async function init(selector = '.' + CLASS) {
    // Hide debug panel unless explicitly enabled
    const dbg = document.getElementById('debugInfo');
    if (dbg && !DEBUG_ENABLED) { dbg.style.display = 'none'; }

    const boxes = Array.from(document.querySelectorAll(selector));
    const roList = [];
    for (const root of boxes) {
      const imgs = Array.from(root.querySelectorAll('img'));
      await Promise.all(imgs.map(preload));
      await raf2();
      layoutBox(root);
      const debouncedLayout = debounce(() => layoutBox(root), 80);
      const ro = new ResizeObserver(debouncedLayout);
      ro.observe(root);
      roList.push(ro);
    }
    window.CollageModes = {
      relayout() { boxes.forEach(layoutBox); },
      disconnect() { roList.forEach(ro => ro.disconnect()); }
    };

    // Auto cleanup observers on page lifecycle end
    try {
      window.addEventListener('pagehide', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
      window.addEventListener('beforeunload', () => {
        try { window.CollageModes && window.CollageModes.disconnect(); } catch(_) {}
      }, { once: true });
    } catch(_) {}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => init());
  } else {
    init();
  }
})();
</script>

</body>
</html>
